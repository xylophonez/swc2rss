import Arweave from 'arweave';
import { ContractDefinition, ExecutionContext, ExecutorFactory, InteractionTx } from '../../..';
/**
 * A handle that effectively runs contract's code.
 */
export interface HandlerApi<State> {
    handle<Input, Result>(executionContext: ExecutionContext<State>, state: State, interaction: ContractInteraction<Input>, interactionTx: InteractionTx, currentTx: {
        interactionTxId: string;
        contractTxId: string;
    }[]): Promise<InteractionResult<State, Result>>;
}
/**
 * A factory that produces handlers that are compatible with the "current" style of
 * writing SW contracts (ie. using "handle" function).
 * Note: this code is mostly ported from the previous version of the SDK and is somewhat messy...
 * First candidate for the refactor!
 */
export declare class HandlerExecutorFactory implements ExecutorFactory<HandlerApi<unknown>> {
    private readonly arweave;
    private readonly logger;
    constructor(arweave: Arweave);
    create<State>(contractDefinition: ContractDefinition<State>): Promise<HandlerApi<State>>;
    private assignViewContractState;
    private assignReadContractState;
    private static normalizeContractSource;
}
export declare type HandlerFunction<State, Input, Result> = (state: State, interaction: ContractInteraction<Input>) => Promise<HandlerResult<State, Result>>;
export declare type HandlerResult<State, Result> = {
    result: Result;
    state: State;
};
export declare type InteractionResult<State, Result> = HandlerResult<State, Result> & {
    type: 'ok' | 'error' | 'exception';
    errorMessage?: string;
};
export declare type ContractInteraction<Input> = {
    input: Input;
    caller: string;
};
//# sourceMappingURL=HandlerExecutorFactory.d.ts.map