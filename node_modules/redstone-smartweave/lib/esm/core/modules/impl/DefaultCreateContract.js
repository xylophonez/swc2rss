import { SmartWeaveTags } from '../../index';
import { LoggerFactory } from '../../../logging/index';
const logger = LoggerFactory.INST.create(__filename);
export class DefaultCreateContract {
    constructor(arweave) {
        this.arweave = arweave;
        this.deployFromSourceTx = this.deployFromSourceTx.bind(this);
    }
    async deploy(contractData) {
        logger.debug('Creating new contract');
        const { wallet, src, initState, tags, transfer } = contractData;
        const srcTx = await this.arweave.createTransaction({ data: src }, wallet);
        srcTx.addTag(SmartWeaveTags.APP_NAME, 'SmartWeaveContractSource');
        // TODO: version should be taken from the current package.json version.
        srcTx.addTag(SmartWeaveTags.APP_VERSION, '0.3.0');
        srcTx.addTag('Content-Type', 'application/javascript');
        await this.arweave.transactions.sign(srcTx, wallet);
        logger.debug('Posting transaction with source');
        const response = await this.arweave.transactions.post(srcTx);
        if (response.status === 200 || response.status === 208) {
            return await this.deployFromSourceTx({
                srcTxId: srcTx.id,
                wallet,
                initState,
                tags,
                transfer
            });
        }
        else {
            throw new Error('Unable to write Contract Source.');
        }
    }
    async deployFromSourceTx(contractData) {
        logger.debug('Creating new contract from src tx');
        const { wallet, srcTxId, initState, tags, transfer } = contractData;
        let contractTX = await this.arweave.createTransaction({ data: initState }, wallet);
        if (+(transfer === null || transfer === void 0 ? void 0 : transfer.winstonQty) > 0 && transfer.target.length) {
            logger.debug('Creating additional transaction with AR transfer', transfer);
            contractTX = await this.arweave.createTransaction({
                data: initState,
                target: transfer.target,
                quantity: transfer.winstonQty
            }, wallet);
        }
        if (tags === null || tags === void 0 ? void 0 : tags.length) {
            for (const tag of tags) {
                contractTX.addTag(tag.name.toString(), tag.value.toString());
            }
        }
        contractTX.addTag(SmartWeaveTags.APP_NAME, 'SmartWeaveContract');
        contractTX.addTag(SmartWeaveTags.APP_VERSION, '0.3.0');
        contractTX.addTag(SmartWeaveTags.CONTRACT_SRC_TX_ID, srcTxId);
        contractTX.addTag('Content-Type', 'application/json');
        await this.arweave.transactions.sign(contractTX, wallet);
        const response = await this.arweave.transactions.post(contractTX);
        if (response.status === 200 || response.status === 208) {
            return contractTX.id;
        }
        else {
            throw new Error('Unable to write Contract Initial State');
        }
    }
    update(contractTxId, contractData) {
        throw new Error('Not implemented yet');
    }
}
//# sourceMappingURL=DefaultCreateContract.js.map