import { Benchmark, deepCopy, EvalStateResult, LoggerFactory, MemCache, TagsParser } from '../../..';
// FIXME: currently this is tightly coupled with the HandlerApi
export class DefaultStateEvaluator {
    constructor(arweave, executionContextModifiers = []) {
        this.arweave = arweave;
        this.executionContextModifiers = executionContextModifiers;
        this.logger = LoggerFactory.INST.create('DefaultStateEvaluator');
        this.transactionStateCache = new MemCache();
        this.tagsParser = new TagsParser();
    }
    async eval(executionContext, currentTx) {
        return this.doReadState(executionContext.sortedInteractions, new EvalStateResult(executionContext.contractDefinition.initState, {}), executionContext, currentTx);
    }
    async doReadState(missingInteractions, baseState, executionContext, currentTx) {
        const stateEvaluationBenchmark = Benchmark.measure();
        const { ignoreExceptions } = executionContext.evaluationOptions;
        let currentState = baseState.state;
        let validity = deepCopy(baseState.validity);
        this.logger.info(`Evaluating state for ${executionContext.contractDefinition.txId} [${missingInteractions.length} non-cached of ${executionContext.sortedInteractions.length} all]`);
        this.logger.trace('missingInteractions', missingInteractions.map((int) => {
            return int.node.id;
        }));
        this.logger.trace('Init state', JSON.stringify(baseState.state));
        for (const missingInteraction of missingInteractions) {
            const currentInteraction = missingInteraction.node;
            this.logger.debug(`[${executionContext.contractDefinition.txId}][${missingInteraction.node.id}]: ${missingInteractions.indexOf(missingInteraction) + 1}/${missingInteractions.length} [of all:${executionContext.sortedInteractions.length}]`);
            const state = await this.onNextIteration(currentInteraction, executionContext);
            if (state !== null) {
                this.logger.debug('Found in cache');
                currentState = state.state;
                validity = state.validity;
            }
            else {
                const singleInteractionBenchmark = Benchmark.measure();
                const inputTag = this.tagsParser.getInputTag(missingInteraction, executionContext.contractDefinition.txId);
                if (!inputTag) {
                    this.logger.error(`Skipping tx with missing or invalid Input tag - ${currentInteraction.id}`);
                    continue;
                }
                const input = this.parseInput(inputTag);
                if (!input) {
                    this.logger.error(`Skipping tx with missing or invalid Input tag - ${currentInteraction.id}`);
                    continue;
                }
                const interaction = {
                    input,
                    caller: currentInteraction.owner.address
                };
                const result = await executionContext.handler.handle(executionContext, currentState, interaction, currentInteraction, currentTx);
                this.logResult(result, currentInteraction, executionContext);
                if (result.type === 'exception' && ignoreExceptions !== true) {
                    throw new Error(`Exception while processing ${JSON.stringify(interaction)}:\n${result.result}`);
                }
                if (result.type === 'exception') {
                    this.logger.error('Credit:', currentState.credit);
                }
                validity[currentInteraction.id] = result.type === 'ok';
                // strangely - state is for some reason modified for some contracts (eg. YLVpmhSq5JmLltfg6R-5fL04rIRPrlSU22f6RQ6VyYE)
                // when calling any async (even simple timeout) function here...
                // that's (ie. deepCopy) a dumb workaround for this issue
                // see https://github.com/ArweaveTeam/SmartWeave/pull/92 for more details
                currentState = deepCopy(result.state);
                this.logger.debug('Interaction evaluation', singleInteractionBenchmark.elapsed());
            }
            await this.onStateUpdate(currentInteraction, executionContext, new EvalStateResult(currentState, validity));
            // I'm really NOT a fan of this "modify" feature, but I don't have idea how to better
            // implement the "evolve" feature
            for (const { modify } of this.executionContextModifiers) {
                executionContext = await modify(currentState, executionContext);
            }
        }
        this.logger.debug('State evaluation total:', stateEvaluationBenchmark.elapsed());
        return new EvalStateResult(currentState, validity);
    }
    logResult(result, currentTx, executionContext) {
        if (result.type === 'exception') {
            this.logger.error(`Executing of interaction: [${executionContext.contractDefinition.srcTxId} -> ${currentTx.id}] threw exception:`, `${result.errorMessage}`);
        }
        if (result.type === 'error') {
            this.logger.warn(`Executing of interaction: [${executionContext.contractDefinition.srcTxId} -> ${currentTx.id}] returned error:`, result.errorMessage);
        }
    }
    parseInput(inputTag) {
        try {
            return JSON.parse(inputTag.value);
        }
        catch (e) {
            this.logger.error(e);
            return null;
        }
    }
    async onStateUpdate(currentInteraction, executionContext, state) {
        if (executionContext.evaluationOptions.fcpOptimization) {
            this.transactionStateCache.put(`${executionContext.contractDefinition.txId}|${currentInteraction.id}`, deepCopy(state));
        }
    }
    async onNextIteration(currentInteraction, executionContext) {
        const cacheKey = `${executionContext.contractDefinition.txId}|${currentInteraction.id}`;
        const cachedState = this.transactionStateCache.get(cacheKey);
        if (cachedState == null) {
            return null;
        }
        else {
            return deepCopy(cachedState);
        }
    }
}
//# sourceMappingURL=DefaultStateEvaluator.js.map