import BigNumber from 'bignumber.js';
import * as clarity from '@weavery/clarity';
import { deepCopy, LoggerFactory, SmartWeaveGlobal } from '../../..';
/**
 * A factory that produces handlers that are compatible with the "current" style of
 * writing SW contracts (ie. using "handle" function).
 * Note: this code is mostly ported from the previous version of the SDK and is somewhat messy...
 * First candidate for the refactor!
 */
export class HandlerExecutorFactory {
    constructor(arweave) {
        this.arweave = arweave;
        this.logger = LoggerFactory.INST.create('HandlerExecutorFactory');
        this.assignReadContractState = this.assignReadContractState.bind(this);
        this.assignViewContractState = this.assignViewContractState.bind(this);
    }
    async create(contractDefinition) {
        const normalizedSource = HandlerExecutorFactory.normalizeContractSource(contractDefinition.src);
        const swGlobal = new SmartWeaveGlobal(this.arweave, {
            id: contractDefinition.txId,
            owner: contractDefinition.owner
        });
        const contractFunction = new Function(normalizedSource);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const contractLogger = LoggerFactory.INST.create('Contract');
        return {
            async handle(executionContext, state, interaction, interactionTx, currentTx) {
                try {
                    const handler = contractFunction(swGlobal, BigNumber, clarity, contractLogger);
                    const stateCopy = JSON.parse(JSON.stringify(state));
                    swGlobal._activeTx = interactionTx;
                    self.logger.trace(`SmartWeave.contract.id:`, swGlobal.contract.id);
                    self.assignReadContractState(swGlobal, contractDefinition, executionContext, currentTx);
                    self.assignViewContractState(swGlobal, contractDefinition, executionContext);
                    const handlerResult = await handler(stateCopy, interaction);
                    if (handlerResult && (handlerResult.state || handlerResult.result)) {
                        return {
                            type: 'ok',
                            result: handlerResult.result,
                            state: handlerResult.state || state
                        };
                    }
                    // Will be caught below as unexpected exception.
                    throw new Error(`Unexpected result from contract: ${JSON.stringify(handlerResult)}`);
                }
                catch (err) {
                    switch (err.name) {
                        case 'ContractError':
                            return {
                                type: 'error',
                                errorMessage: err.message,
                                state,
                                // note: previous version was writing error message to a "result" field,
                                // which fucks-up the HandlerResult type definition -
                                // HandlerResult.result had to be declared as 'Result | string' - and that led to a poor dev exp.
                                // TODO: this might be breaking change!
                                result: null
                            };
                        default:
                            return {
                                type: 'exception',
                                errorMessage: `${(err && err.stack) || (err && err.message)}`,
                                state,
                                result: null
                            };
                    }
                }
            }
        };
    }
    assignViewContractState(swGlobal, contractDefinition, executionContext) {
        swGlobal.contracts.viewContractState = async (contractTxId, input) => {
            this.logger.debug('swGlobal.viewContractState call:', {
                from: contractDefinition.txId,
                to: contractTxId,
                input
            });
            const childContract = executionContext.smartweave
                .contract(contractTxId, executionContext.contract)
                .setEvaluationOptions(executionContext.evaluationOptions);
            return await childContract.viewStateForTx(input, swGlobal._activeTx);
        };
    }
    assignReadContractState(swGlobal, contractDefinition, executionContext, currentTx) {
        swGlobal.contracts.readContractState = async (contractTxId, height, returnValidity) => {
            const requestedHeight = height || swGlobal.block.height;
            this.logger.debug('swGlobal.readContractState call:', {
                from: contractDefinition.txId,
                to: contractTxId,
                height: requestedHeight,
                transaction: swGlobal.transaction.id
            });
            const childContract = executionContext.smartweave
                .contract(contractTxId, executionContext.contract)
                .setEvaluationOptions(executionContext.evaluationOptions);
            const stateWithValidity = await childContract.readState(requestedHeight, [
                ...(currentTx || []),
                {
                    contractTxId: contractDefinition.txId,
                    interactionTxId: swGlobal.transaction.id
                }
            ]);
            // TODO: it should be up to the client's code to decide which part of the result to use
            // (by simply using destructuring operator)...
            // but this (i.e. returning always stateWithValidity from here) would break backwards compatibility
            // in current contract's source code..:/
            return returnValidity ? deepCopy(stateWithValidity) : deepCopy(stateWithValidity.state);
        };
    }
    static normalizeContractSource(contractSrc) {
        // Convert from ES Module format to something we can run inside a Function.
        // Removes the `export` keyword and adds ;return handle to the end of the function.
        // Additionally it removes 'IIFE' declarations
        // (which may be generated when bundling multiple sources into one output file
        // - eg. using esbuild's "IIFE" bundle format).
        // We also assign the passed in SmartWeaveGlobal to SmartWeave, and declare
        // the ContractError exception.
        // We then use `new Function()` which we can call and get back the returned handle function
        // which has access to the per-instance globals.
        contractSrc = contractSrc
            .replace(/export\s+async\s+function\s+handle/gmu, 'async function handle')
            .replace(/export\s+function\s+handle/gmu, 'function handle')
            .replace(/\(\s*\(\)\s*=>\s*{/g, '')
            .replace(/\s*\(\s*function\s*\(\)\s*{/g, '')
            .replace(/}\s*\)\s*\(\)\s*;/g, '');
        return `
    const [SmartWeave, BigNumber, clarity, logger] = arguments;
    clarity.SmartWeave = SmartWeave;
    class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };
    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };
    ${contractSrc};
    return handle;
  `;
    }
}
//# sourceMappingURL=HandlerExecutorFactory.js.map