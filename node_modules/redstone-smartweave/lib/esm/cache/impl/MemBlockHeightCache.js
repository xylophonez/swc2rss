import { deepCopy } from '../../utils/index';
/**
 * A simple, in-memory cache implementation of the BlockHeightSwCache
 */
export class MemBlockHeightSwCache {
    constructor() {
        this.storage = {};
    }
    async getLast(key) {
        if (!(await this.contains(key))) {
            return null;
        }
        const cached = this.storage[key];
        // sort keys (ie. block heights) in asc order and get
        // the last element (ie. highest cached block height).
        const highestBlockHeight = [...cached.keys()].sort().pop();
        return {
            cachedHeight: highestBlockHeight,
            cachedValue: deepCopy(cached.get(highestBlockHeight))
        };
    }
    async getLessOrEqual(key, blockHeight) {
        if (!(await this.contains(key))) {
            return null;
        }
        const cached = this.storage[key];
        // find first element in and desc-sorted keys array that is not higher than requested block height
        const highestBlockHeight = [...cached.keys()]
            .sort()
            .reverse()
            .find((cachedBlockHeight) => {
            return cachedBlockHeight <= blockHeight;
        });
        return {
            cachedHeight: highestBlockHeight,
            cachedValue: deepCopy(cached.get(highestBlockHeight))
        };
    }
    async put({ cacheKey, blockHeight }, value) {
        if (!(await this.contains(cacheKey))) {
            this.storage[cacheKey] = new Map();
        }
        this.storage[cacheKey].set(blockHeight, deepCopy(value));
    }
    async contains(key) {
        return Object.prototype.hasOwnProperty.call(this.storage, key);
    }
    async get(key, blockHeight) {
        if (!(await this.contains(key))) {
            return null;
        }
        if (!this.storage[key].has(blockHeight)) {
            return null;
        }
        return {
            cachedHeight: blockHeight,
            cachedValue: deepCopy(this.storage[key].get(blockHeight))
        };
    }
}
//# sourceMappingURL=MemBlockHeightCache.js.map