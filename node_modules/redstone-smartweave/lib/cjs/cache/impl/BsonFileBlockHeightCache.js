"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BsonFileBlockHeightSwCache = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const bson_1 = __importDefault(require("bson"));
const logging_1 = require("../../logging/index");
const utils_1 = require("../../utils/index");
/**
 * An implementation of {@link BlockHeightSwCache} that stores its data in BSON files.
 * Data is flushed to disk every 10 new cache entries.
 *
 * Main use-case is the per block height state cache for contracts.
 *
 * A separate file is created for each block height - otherwise it was common to
 * hit 16 megabytes file size limit for bson files.
 *
 * At time of writing, completely cached state for all contracts, at all block heights,
 * was taking ~2.5GB of disk space :-).
 *
 * The files are organised in the following structure:
 * --/basePath
 *   --/txId_1
 *     --1.cache.bson
 *     --2.cache.bson
 *     ...
 *     --748832.cache.bson
 *   --/txId_2
 *     --1.cache.bson
 *     --323332.cache.bson
 * ...etc.
 *
 * Note: this is not performance-optimized for reading LARGE amount of contracts ;-)
 */
class BsonFileBlockHeightSwCache {
    constructor(basePath) {
        this.logger = logging_1.LoggerFactory.INST.create('BsonFileBlockHeightSwCache');
        this.updatedStorage = {};
        this.saving = false;
        this.putCounter = 0;
        this.saveCache = this.saveCache.bind(this);
        this.storage = {};
        this.basePath = basePath ? basePath : path_1.default.join(__dirname, 'storage', 'state');
        if (!fs_1.default.existsSync(this.basePath)) {
            fs_1.default.mkdirSync(this.basePath);
        }
        const directories = fs_1.default.readdirSync(this.basePath);
        directories.forEach((directory) => {
            const cacheDirPath = path_1.default.join(this.basePath, directory);
            if (this.storage[directory] == null) {
                this.storage[directory] = {};
            }
            const benchmark = logging_1.Benchmark.measure();
            const files = fs_1.default.readdirSync(cacheDirPath);
            files.forEach((file) => {
                const cacheFilePath = path_1.default.join(cacheDirPath, file);
                const height = file.split('.')[0];
                const cache = bson_1.default.deserialize(fs_1.default.readFileSync(path_1.default.join(cacheFilePath)));
                this.storage[directory][height] = cache;
            });
            this.logger.debug(`loading cache for ${directory}`, benchmark.elapsed());
        });
        this.logger.debug('Storage keys', Object.keys(this.storage));
        process.on('exit', () => {
            this.saveCache();
            process.exit();
        });
        process.on('SIGINT', () => {
            this.saveCache();
            process.exit();
        });
    }
    saveCache() {
        if (this.saving) {
            return;
        }
        this.saving = true;
        // TODO: switch to async, as currently writing cache files may slow down contract execution.
        try {
            this.logger.debug(`==== Storing cache update [${Object.keys(this.updatedStorage).length}] ====`);
            const directoryPath = this.basePath;
            Object.keys(this.updatedStorage).forEach((key) => {
                const directory = key;
                if (!fs_1.default.existsSync(path_1.default.join(directoryPath, directory))) {
                    fs_1.default.mkdirSync(path_1.default.join(directoryPath, directory));
                }
                for (const height of Object.keys(this.updatedStorage[key])) {
                    fs_1.default.writeFileSync(path_1.default.join(directoryPath, directory, `${height}.cache.bson`), bson_1.default.serialize(this.updatedStorage[key][height]));
                }
            });
        }
        finally {
            this.saving = false;
        }
    }
    async getLast(key) {
        if (!(await this.contains(key))) {
            return null;
        }
        const cached = this.storage[key];
        // sort keys (ie. block heights) in asc order and get
        // the first element (ie. highest cached block height).
        const highestBlockHeight = Object.keys(cached)
            .map((k) => +k)
            .sort()
            .pop();
        return {
            cachedHeight: highestBlockHeight,
            cachedValue: (0, utils_1.deepCopy)(cached[highestBlockHeight + ''])
        };
    }
    async getLessOrEqual(key, blockHeight) {
        if (!(await this.contains(key))) {
            return null;
        }
        const cached = this.storage[key];
        // find first element in a desc-sorted keys array that is not higher than requested block height
        const highestBlockHeight = Object.keys(cached)
            .map((k) => +k)
            .sort()
            .reverse()
            .find((cachedBlockHeight) => {
            return cachedBlockHeight <= blockHeight;
        });
        // if no such element in cache
        if (highestBlockHeight === undefined) {
            return null;
        }
        return {
            cachedHeight: highestBlockHeight,
            cachedValue: (0, utils_1.deepCopy)(cached[highestBlockHeight + ''])
        };
    }
    async put({ cacheKey, blockHeight }, value) {
        if (!(await this.contains(cacheKey))) {
            this.storage[cacheKey] = {};
        }
        if (!Object.prototype.hasOwnProperty.call(this.updatedStorage, cacheKey)) {
            this.updatedStorage[cacheKey] = {};
        }
        const copiedValue = (0, utils_1.deepCopy)(value);
        this.storage[cacheKey][blockHeight + ''] = copiedValue;
        this.updatedStorage[cacheKey][blockHeight + ''] = copiedValue;
        this.putCounter++;
        // update disk cache every 10 new entries
        if (this.putCounter === 10) {
            this.putCounter = 0;
            this.saveCache();
            this.updatedStorage = {};
        }
    }
    async contains(key) {
        return Object.prototype.hasOwnProperty.call(this.storage, key);
    }
    async get(key, blockHeight) {
        throw new Error('Not implemented yet');
    }
}
exports.BsonFileBlockHeightSwCache = BsonFileBlockHeightSwCache;
//# sourceMappingURL=BsonFileBlockHeightCache.js.map